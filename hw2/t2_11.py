def f(n):
    sum = 0
    for i in range(1,n + 1):
        sum += i
    return sum



def g(n):
    sum = 0                    #O(1)
    for i in range(1,n+1):     #O(n^2)
        sum = sum + i + f(i)   #O(n^2)
    return sum                 #O(1)


#f(i) = O(i)
#sum{i=1;n} O(i) = O(1) + O(2) + ... + O(n) =
# = O (sum{i = 1; n}) => O(n(n+1) / 2) = O(n^2)

#У найгіршому випадку g(n) = O(n^2)

# Якщо взяти покращену версію f(n)=O(1) отримаємо тепер наступне
# (щоб не переписувати постійно візьмемо,що будь-яка сума наступна буде по і
# від 1 до n
# sum(i + i(i + 1) / 2) = sum(i) + sum(i(i + 1) / 2 =
# Першу суму ми вже знайшли раніше і її складність O(n^2)
# sum((i^2 + i) / 2) = 1/2sum(i) + 1/2sum(i^2)
# Аналогічно перша сума буде O(n^2)
# sum(i) ='геометрична прогресія' (n(n+1)(2n + 1)) / 6 =
# O(n^3)
# Отже так складність не зменшиться, проте весь цикл як у випадку з f(n)
# можна замінити прямим пошуком значення суми
# Цей пошук також показує результат виконання функції для n


def g(n):
    return (n * (n + 1)) // 2 + (n * (n + 1) * (2 * n + 1)) // 6 + (n * (n + 1)) // 4

#Тут g(n) = O(1)